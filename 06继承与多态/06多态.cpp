/*
如何理解多态
静态（编译时期）的多态：函数重载、模板（函数模板和类模板）
bool compare(int,int){}
bool compare(double,double){}

compare(10,20); call compare_int_int 在编译阶段就确定好调用函数的版本
compare(10.5,20.5); call compare_double_double 在编译阶段就确定好调用函数的版本

template<typename T>
bool compare(T a,T b){}

compare(10,20); => int 实例化一个 compare<int>
compare(10.5,20.5); => double 实例化一个 compare<double>

动态（运行时期）的多态：  Base Derive
在继承结构中，基类指针（引用）指向派生类对象，通过该指针（引用）调用同名覆盖方法（虚函数），
基类指针指向哪个派生类对象，就会调用哪个派生类对象的同名覆盖方法，称为多态
pbase->bark();
多态底层是通过动态绑定来实现的，pbase-> 访问谁的 vfptr-> 继续访问谁的vftable
                                     ->调用的就是对应的派生类对象的方法

继承的好处是什么？
1.可以做代码的复用
2.在基类中提供统一的虚函数接口，让派生类重写，然后就可以使用多态了
*/

#include <iostream>
#include <string>
using namespace std;

class Animal {
public:
    Animal(string name):_name(name){}
    virtual void bark(){}
protected:
    string _name;
};

class Cat :public Animal {
public:
    Cat(string name):Animal(name){}
    void bark() { cout <<_name << "bark:miao miao!" << endl; }
};

class Dog :public Animal {
public:
    Dog(string name):Animal(name){}
    void bark() { cout <<_name << "bark:wang wang!" << endl; }
};

class Pig :public Animal {
public:
    Pig(string name) :Animal(name) {}
    void bark() { cout << _name << "bark:heng heng!" << endl; }
};

/*
下面的一组bark API接口无法做到软件涉及的"开-闭"原则
软件设计有六大原则  “开-闭”原则   对修改关闭，对扩展开放

void bark(Cat& cat) {
    cat.bark();
}

void bark(Dog& dog) {
    dog.bark();
}

void bark(Pig& pig) {
    pig.bark();
}
*/

void bark(Animal* p) {
    p->bark(); // Animal::bark虚函数，动态绑定了
    /*
    p->cat Cat vftable  &Cat::bark()
    p->dog Dog vftable  &Dog::bark()
    p->pig Pig vftable  &Pig::bark()
    */
}

int main() {
    Cat cat("猫咪");
    Dog dog("二哈");
    Pig pig("佩奇");

    bark(&cat);
    bark(&dog);
    bark(&pig);

    return 0;
}